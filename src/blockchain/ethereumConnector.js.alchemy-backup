/**
 * Ethereum Blockchain Connector
 * 
 * Handles interactions with the Ethereum blockchain including:
 * - Wallet connection and management
 * - Token trading via DEXes (Uniswap)
 * - Token price queries
 * - Gas price optimization
 */

const { ethers } = require('ethers');
const { ERC20_ABI } = require('../abis');

// Uniswap Router ABI (simplified)
const UNISWAP_ROUTER_ABI = [
  "function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)",
  "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)",
  "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)"
];

// Uniswap Factory ABI (simplified)
const UNISWAP_FACTORY_ABI = [
  "function getPair(address tokenA, address tokenB) external view returns (address pair)"
];

// Uniswap Pair ABI (simplified)
const UNISWAP_PAIR_ABI = [
  "function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
  "function token0() external view returns (address)",
  "function token1() external view returns (address)"
];

class EthereumConnector {
  constructor(privateKey, alchemyKey, logger) {
    this.privateKey = privateKey;
    this.alchemyKey = alchemyKey;
    this.logger = logger;
    
    // Contract addresses
    this.uniswapRouterAddress = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'; // Uniswap V2 Router
    this.uniswapFactoryAddress = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f'; // Uniswap V2 Factory
    this.wethAddress = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'; // WETH
    
    this.provider = null;
    this.wallet = null;
    this.signer = null;
    this.uniswapRouter = null;
    this.uniswapFactory = null;
  }
  
  /**
   * Initialize the connector
   */
  async initialize() {
    // Ensure private key has 0x prefix for ethers.js
    if (this.privateKey && !this.privateKey.startsWith('0x')) {
      this.privateKey = `0x${this.privateKey}`;
    }

    // Ensure private key has 0x prefix for ethers.js
    if (this.privateKey && !this.privateKey.startsWith('0x')) {
      this.privateKey = `0x${this.privateKey}`;
    }

    try {
      this.logger.info('Initializing Ethereum connector');
      
      // Create provider
      const providerUrl = `https://eth-mainnet.g.alchemy.com/v2/${this.alchemyKey}`;
      this.provider = new ethers.providers.JsonRpcProvider(providerUrl);
      
      // Create wallet
      this.wallet = new ethers.Wallet(this.privateKey, this.provider);
      this.signer = this.wallet;
      
      // Create contract instances
      this.uniswapRouter = new ethers.Contract(
        this.uniswapRouterAddress,
        UNISWAP_ROUTER_ABI,
        this.signer
      );
      
      this.uniswapFactory = new ethers.Contract(
        this.uniswapFactoryAddress,
        UNISWAP_FACTORY_ABI,
        this.provider
      );
      
      // Get wallet address
      this.address = await this.wallet.getAddress();
      
      this.logger.info('Ethereum connector initialized successfully');
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize Ethereum connector', error);
      throw error;
    }
  }
  
  /**
   * Get the connected wallet
   */
  async getWallet() {
    return this.wallet;
  }
  
  /**
   * Get balances for the connected wallet
   */
  async getBalances() {
    try {
      // Get ETH balance
      const ethBalance = await this.provider.getBalance(this.address);
      const ethBalanceFormatted = parseFloat(ethers.utils.formatEther(ethBalance));
      
      // Initialize balances object
      const balances = {
        'ETH': ethBalanceFormatted
      };
      
      // Get USDT balance if available
      try {
        const usdtAddress = '0xdAC17F958D2ee523a2206206994597C13D831ec7'; // USDT
        const usdtContract = new ethers.Contract(usdtAddress, ERC20_ABI, this.provider);
        const usdtBalance = await usdtContract.balanceOf(this.address);
        const usdtDecimals = await usdtContract.decimals();
        balances['USDT'] = parseFloat(ethers.utils.formatUnits(usdtBalance, usdtDecimals));
      } catch (e) {
        // Ignore USDT errors
      }
      
      return balances;
    } catch (error) {
      this.logger.error('Error getting Ethereum balances', error);
      return { 'ETH': 0 };
    }
  }
  
  /**
   * Get token price in ETH
   */
  async getTokenPrice(tokenAddress) {
    try {
      // Get pair address from factory
      const pairAddress = await this.uniswapFactory.getPair(tokenAddress, this.wethAddress);
      
      if (pairAddress === '0x0000000000000000000000000000000000000000') {
        throw new Error('No liquidity pair found');
      }
      
      // Get pair contract
      const pairContract = new ethers.Contract(pairAddress, UNISWAP_PAIR_ABI, this.provider);
      
      // Get reserves
      const reserves = await pairContract.getReserves();
      
      // Get token order
      const token0 = await pairContract.token0();
      
      // Calculate price based on token order
      let price;
      if (token0.toLowerCase() === tokenAddress.toLowerCase()) {
        // Token is token0, WETH is token1
        price = parseFloat(ethers.utils.formatEther(reserves[1])) / 
                parseFloat(ethers.utils.formatUnits(reserves[0], 18));
      } else {
        // Token is token1, WETH is token0
        price = parseFloat(ethers.utils.formatEther(reserves[0])) / 
                parseFloat(ethers.utils.formatUnits(reserves[1], 18));
      }
      
      // Convert ETH price to USD (estimate)
      const ethUsdPrice = 2000; // This should be fetched from an API in a real implementation
      return price * ethUsdPrice;
    } catch (error) {
      this.logger.error(`Error getting price for token ${tokenAddress}`, error);
      return null;
    }
  }
  
  /**
   * Execute a buy (ETH to Token)
   */
  async executeBuy(tokenAddress, walletPercentage) {
    try {
      this.logger.info(`Executing buy for token ${tokenAddress}`);
      
      // Get ETH balance
      const ethBalance = await this.provider.getBalance(this.address);
      
      // Calculate amount to spend (leave some for gas)
      const gasReserve = ethers.utils.parseEther('0.05'); // 0.05 ETH for gas
      
      if (ethBalance.lte(gasReserve)) {
        throw new Error('Insufficient ETH balance for gas reserve');
      }
      
      const availableBalance = ethBalance.sub(gasReserve);
      const amountToSpend = availableBalance.mul(ethers.BigNumber.from(Math.floor(walletPercentage * 100)))
                                          .div(ethers.BigNumber.from(100));
      
      // Get current gas price
      const gasPrice = await this.provider.getGasPrice();
      
      // Apply multiplier for faster confirmation
      const gasMultiplier = 1.1; // 10% extra
      const adjustedGasPrice = gasPrice.mul(ethers.BigNumber.from(Math.floor(gasMultiplier * 100)))
                                     .div(ethers.BigNumber.from(100));
      
      // Prepare swap parameters
      const path = [this.wethAddress, tokenAddress];
      const deadline = Math.floor(Date.now() / 1000) + 60 * 10; // 10 minutes
      
      // Get expected output
      const amountsOut = await this.uniswapRouter.getAmountsOut(amountToSpend, path);
      
      // Apply slippage tolerance
      const slippageTolerance = 0.05; // 5%
      const minAmountOut = amountsOut[1].mul(ethers.BigNumber.from(Math.floor((1 - slippageTolerance) * 1000)))
                                     .div(ethers.BigNumber.from(1000));
      
      // Execute swap
      const tx = await this.uniswapRouter.swapExactETHForTokens(
        minAmountOut,
        path,
        this.address,
        deadline,
        {
          value: amountToSpend,
          gasPrice: adjustedGasPrice,
          gasLimit: 300000 // Adjusted based on token complexity
        }
      );
      
      this.logger.info(`Buy transaction sent: ${tx.hash}`);
      
      // Wait for confirmation
      const receipt = await tx.wait();
      
      this.logger.info(`Buy transaction confirmed: ${receipt.transactionHash}`);
      
      // Get token contract to check balance
      const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, this.provider);
      const tokenBalance = await tokenContract.balanceOf(this.address);
      const tokenDecimals = await tokenContract.decimals();
      
      // Get token symbol
      let tokenSymbol;
      try {
        tokenSymbol = await tokenContract.symbol();
      } catch (e) {
        tokenSymbol = 'UNKNOWN';
      }
      
      // Format balance
      const formattedBalance = ethers.utils.formatUnits(tokenBalance, tokenDecimals);
      
      // Return trade details
      return {
        symbol: `${tokenSymbol}/ETH`,
        amount: parseFloat(ethers.utils.formatEther(amountToSpend)),
        entryPrice: parseFloat(ethers.utils.formatEther(amountToSpend)) / parseFloat(formattedBalance),
        tokenAmount: parseFloat(formattedBalance),
        transactionHash: receipt.transactionHash
      };
    } catch (error) {
      this.logger.error(`Error executing buy for token ${tokenAddress}`, error);
      throw error;
    }
  }
  
  /**
   * Execute a sell (Token to ETH)
   */
  async executeSell(tokenAddress) {
    try {
      this.logger.info(`Executing sell for token ${tokenAddress}`);
      
      // Get token contract
      const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, this.signer);
      
      // Get token balance
      const tokenBalance = await tokenContract.balanceOf(this.address);
      
      if (tokenBalance.isZero()) {
        throw new Error('No tokens to sell');
      }
      
      // Get token details
      const tokenDecimals = await tokenContract.decimals();
      let tokenSymbol;
      try {
        tokenSymbol = await tokenContract.symbol();
      } catch (e) {
        tokenSymbol = 'UNKNOWN';
      }
      
      // Approve router to spend tokens
      const approveTx = await tokenContract.approve(this.uniswapRouterAddress, tokenBalance);
      await approveTx.wait();
      
      this.logger.info(`Token approval confirmed: ${approveTx.hash}`);
      
      // Get current gas price
      const gasPrice = await this.provider.getGasPrice();
      
      // Apply multiplier for faster confirmation
      const gasMultiplier = 1.1; // 10% extra
      const adjustedGasPrice = gasPrice.mul(ethers.BigNumber.from(Math.floor(gasMultiplier * 100)))
                                     .div(ethers.BigNumber.from(100));
      
      // Prepare swap parameters
      const path = [tokenAddress, this.wethAddress];
      const deadline = Math.floor(Date.now() / 1000) + 60 * 10; // 10 minutes
      
      // Get expected output
      const amountsOut = await this.uniswapRouter.getAmountsOut(tokenBalance, path);
      
      // Apply slippage tolerance
      const slippageTolerance = 0.05; // 5%
      const minAmountOut = amountsOut[1].mul(ethers.BigNumber.from(Math.floor((1 - slippageTolerance) * 1000)))
                                     .div(ethers.BigNumber.from(1000));
      
      // Execute swap
      const tx = await this.uniswapRouter.swapExactTokensForETH(
        tokenBalance,
        minAmountOut,
        path,
        this.address,
        deadline,
        {
          gasPrice: adjustedGasPrice,
          gasLimit: 300000 // Adjusted based on token complexity
        }
      );
      
      this.logger.info(`Sell transaction sent: ${tx.hash}`);
      
      // Wait for confirmation
      const receipt = await tx.wait();
      
      this.logger.info(`Sell transaction confirmed: ${receipt.transactionHash}`);
      
      // Return trade details
      return {
        symbol: `${tokenSymbol}/ETH`,
        amount: parseFloat(ethers.utils.formatUnits(tokenBalance, tokenDecimals)),
        exitPrice: parseFloat(ethers.utils.formatEther(minAmountOut)),
        transactionHash: receipt.transactionHash
      };
    } catch (error) {
      this.logger.error(`Error executing sell for token ${tokenAddress}`, error);
      throw error;
    }
  }
}

module.exports = { EthereumConnector };
